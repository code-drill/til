<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Today I Learned (Posts about mongodb)</title><link>https://til.code-drill.eu/</link><description></description><atom:link href="https://til.code-drill.eu/categories/mongodb.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2025 &lt;a href="mailto:michal@code-drill.eu"&gt;Michał Rutkowski&lt;/a&gt; </copyright><lastBuildDate>Sun, 21 Sep 2025 10:20:52 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Using top in mongodb aggregation</title><link>https://til.code-drill.eu/posts/2025-06-22/using-top-in-mongodb-aggregation/</link><dc:creator>Michał Rutkowski</dc:creator><description>&lt;p&gt;As mongo docs says:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MongoDB aggregation stage limits
Each stage can use up to 100 MB of RAM. You will get an error from the database if you exceed this limit. &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So if you are having this problem and you need the first (or last)
element from a sorted collection, you can use the top operator.&lt;/p&gt;
&lt;p&gt;So instead of sorting:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;db.Entity.aggregate([
    {
        "$match": {
            "startTime": {
                "$gte": ISODate("2025-04-02T22:00:00Z"),
                "$lt": ISODate("2025-04-03T22:00:00Z")
                }
            }
        },
    {
        "$addFields": {
            "creatorPriority": {
                "$switch": {
                    "branches": [
                        { "case": { "$eq": ["$creator", "ADMIN"] }, "then": 1 }
                        ],
                    "default": 0
                    }
                }
            }
        },
    {
        "$sort": {
            "creatorPriority": -1,
            "createdAt": -1
            }
        },
    {
        "$group": {
            "_id": {
                "deviceId": "$deviceId",
                "startTime": "$startTime"
                },
            "records": { "$push": "$$CURRENT" }
            }
        },
    {
        "$replaceRoot": {
            "newRoot": { "$first": "$records" }
            }
        }
    ])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use top:&lt;/p&gt;
&lt;pre class="mongodb"&gt;&lt;code&gt;db.Entity.aggregate([
    {
        "$match": {
            "startTime": {
                "$gte": ISODate("2025-06-18T22:00:00Z"),
                "$lt": ISODate("2025-06-20T22:00:00Z")
                }
            }
        },
    {
        "$addFields": {
            "creatorPriority": {
                "$switch": {
                    "branches": [
                        { "case": { "$eq": ["$creator", "ADMIN"] }, "then": 1 }
                        ],
                    "default": 0
                }
            }
        }
    },

    {
        "$group": {
            "_id": {
                "entityId": "$entityId",
                "startTime": "$startTime"
                },
            "topRecord": {
                "$top": {
                    "sortBy": { "createdAt": -1 },
                    "output": "$$ROOT"
                    }
                }
            }
        },
    {
        "$replaceRoot": {
            "newRoot": "$topRecord"
            }
        }
    ] , {
    allowDiskUse: false
    })
&lt;/code&gt;&lt;/pre&gt;</description><category>aggregation</category><category>db</category><category>mongodb</category><category>top</category><guid>https://til.code-drill.eu/posts/2025-06-22/using-top-in-mongodb-aggregation/</guid><pubDate>Sun, 22 Jun 2025 18:59:15 GMT</pubDate></item></channel></rss>